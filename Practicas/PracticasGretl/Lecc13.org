#+title:  Lección 13
#+author: Marcos Bujosa
#+STARTUP: show4levels
#+LANGUAGE: es-es

#+EXPORT_FILE_NAME: pub/Lecc13

# +OPTIONS: toc:nil
#+OPTIONS: tags:nil

#+LATEX_CLASS: article

#+LATEX_HEADER: \usepackage[spanish]{babel}
#+LATEX_HEADER: \usepackage[margin=0.5in]{geometry}
#+LaTeX_HEADER: \usepackage[svgnames,x11names]{xcolor}
#+LaTeX_HEADER: \hypersetup{linktoc = all, colorlinks = true, urlcolor = DodgerBlue4, citecolor = PaleGreen1, linkcolor = SpringGreen4}
#+LaTeX_HEADER: \PassOptionsToPackage{hyphens}{url}
#+LaTeX_HEADER: \usepackage{nacal}

#+bibliography: ref.bib

#+LaTeX_HEADER: \usepackage{framed}

#+LaTeX_HEADER: \usepackage{listings}
#+LaTeX_HEADER: \input{hansl.tex}
#+LaTeX_HEADER: \lstnewenvironment{hansl-gretl}
#+LaTeX_HEADER: {\lstset{language={hansl},basicstyle={\ttfamily\footnotesize},numbers,rame=single,breaklines=true}}
#+LaTeX_HEADER: {}
#+LaTeX_HEADER: \newcommand{\hansl}[1]{\lstset{language={hansl},basicstyle={\ttfamily\small}}\lstinline{#1}}
# +LaTeX_HEADER: \lstset{backgroundcolor=\color{white},basicstyle=\ttfamily\footnotesize,breaklines=true, captionpos=b,commentstyle=\color{mygreen},escapeinside={\%*}{*)}, keywordstyle=\color{blue},stringstyle=\color{mymauve}, }
# +LaTeX_HEADER: \lstset{backgroundcolor=\color{lightgray!20},basicstyle=\ttfamily\footnotesize,breaklines=true, }
#+LaTeX_HEADER: \lstset{backgroundcolor=\color{lightgray!20}, }

#+name: setup-listings
#+begin_src emacs-lisp :exports none :results silent
  (setq org-latex-listings 'listings)
  (setq org-latex-custom-lang-environments
  	;'((emacs-lisp "common-lispcode")))
  	'((emacs-lisp "hansl-gretl")))
  (setq org-latex-listings-options
	'(("frame" "lines")
	  ("basicstyle" "\\scriptsize")
	  ("basicstyle" "\\ttfamily")
	  ("numbers=none" "left")
	  ("backgroundcolor=\\color{lightgray!20}")
	  ("numberstyle" "\\tiny")))
  (setq org-latex-to-pdf-process
	'("pdflatex -interaction nonstopmode -output-directory %o %f"
	"pdflatex -interaction nonstopmode -output-directory %o %f"
	"pdflatex -interaction nonstopmode -output-directory %o %f"))
  (org-add-link-type
   "latex" nil
   (lambda (path desc format)
     (cond
      ((eq format 'html)
       (format "<span class=\"%s\">%s</span>" path desc))
      ((eq format 'latex)
       (format "\\%s{%s}" path desc)))))
#+end_src


# \lstnewenvironment{code}
#     {\lstset{language=haskell,
#     basicstyle=\small\ttfamily,
#     numbers=left,
#     numberstyle=\tiny\color{gray},
#     backgroundcolor=\color{lightgray},
#     firstnumber=auto
#     }}
#     {}

#+bibliography: ref.bib

# +latex: \clearpage

#+LATEX: \clearpage

#+macro: lugar [[https://github.com/mbujosab/Ectr/tree/master/Practicas/Gretl/scripts/$1][$1]]

#+macro: codigo \lstinputlisting{scripts/$1} 

* Omisión de un regresor ortogonal al resto de regresores
   :PROPERTIES:
   :header-args: :tangle ./pub/scripts/OmisionRegresorOrtogonal.inp
   :END:

| Guión: | {{{lugar(OmisionRegresorOrtogonal.inp)}}} |


#+begin_src hansl :exports none
nulldata 1000                       # tamano de muestra en la simulacion

loop 5000 --progressive --quiet
     series S = normal(0,10)        # generamos datos S correspondientes a la superficie
     series D = normal(0,1)         # generamos datos D correspondientes a la distancia    
     series U = normal(0,25)        # perturbaciones U: otros factores que afectan el precio

     /* variante para regresores verdaderamente ortogonales (media cero y covarianza cero) */
     /* series SS = normal(0,10)    # generamos datos S correspondientes a la superficie   */
     /* series S = SS - mean(SS)    # con media cero                                       */
     /* series DD = normal(0,1)     # generamos datos D correspondientes a la distancia    */
     /* ols DD 0 S                  # regresion auxiliar                                   */
     /* series D = $uhat            # con media cero y perpendiculares a S                 */

     series P = 100 +3*S -130*D +U  # precios P como combinacion lineal de regresores + U
     
     ols P 0 S D                    # Regresion MCO Verdadero modelo: P = 100 +3*S -130*D +U
     scalar C1 = $coeff(const)
     scalar S1 = $coeff(S)
     scalar D1 = $coeff(D)
     scalar sigma1 = $sigma

     ols P 0 D                      # Regresion MCO omision S
     scalar C2 = $coeff(const)
     scalar D2 = $coeff(D)
     scalar sigma2 = $sigma

     ols P 0 S                      # Regresion MCO omision D
     scalar C3 = $coeff(const)
     scalar S3 = $coeff(S)
     scalar sigma3 = $sigma

     print C1 S1 D1 sigma1 
     print C2    D2 sigma2
     print C3 S3    sigma3
endloop
#+end_src  

# +LATEX: \clearpage
#+latex: \vspace{10pt}
#+latex: \noindent
*Código completo de la práctica*
#+latex: \vspace{10pt}
\lstinputlisting{scripts/OmisionRegresorOrtogonal.inp}
#+LATEX: \clearpage


**** variante                                                      :noexport:
     /* variante para regresores verdaderamente ortogonales (media cero y covarianza cero) */
     # series SS = normal(0,10)       # generamos datos S correspondientes a la superficie
     # series S = SS - mean(SS)       # con media cero
     # series DD = normal(0,1)        # generamos datos D correspondientes a la distancia
     # ols DD 0 S
     # series D = $uhat               # con media cero y perpendiculares a S

* Omisión de un regresor NO ortogonal al resto de regresores
   :PROPERTIES:
   :header-args: :tangle ./pub/scripts/OmisionRegresorNoOrtogonal.inp
   :END:

| Guión: | {{{lugar(OmisionRegresorNoOrtogonal.inp)}}} |


#+begin_src hansl :exports none
nulldata 1000                             # tamano de muestra en la simulacion
loop 5000 --progressive --quiet

     series C = randgen(U, 0   , 40 )     # C: un factor comun en S y D
     series S = randgen(U, 35  ,100 ) + C # datos S correspondientes a la superficie
     series D = randgen(X, 10)        + C # datos D correspondientes a la distancia
     series U = randgen(N, 0   , 40 )     # U: otros factores que afectan a P
     series P = 100 +3*S -130*D +U        # precios P como combinacion lineal de regresores + U
     
     ols P 0 S D                          # Regresion MCO Verdadero modelo: P = 100 +3*S -130*D +U
     scalar C1     = $coeff(const)
     scalar S1     = $coeff(S)
     scalar D1     = $coeff(D)
     scalar sigma1 = $sigma

     ols P 0 D                            # Regresion MCO omision S
     scalar C2     = $coeff(const)
     scalar D2     = $coeff(D)
     scalar sigma2 = $sigma

     ols P 0 S                            # Regresion MCO omision D
     scalar C3     = $coeff(const)
     scalar S3     = $coeff(S)
     scalar sigma3 = $sigma

     print C1 S1 D1 sigma1 
     print C2    D2 sigma2
     print C3 S3    sigma3
endloop
#+end_src  

# +LATEX: \clearpage
#+latex: \vspace{10pt}
#+latex: \noindent
*Código completo de la práctica*
#+latex: \vspace{10pt}
\lstinputlisting{scripts/OmisionRegresorNoOrtogonal.inp}
#+LATEX: \clearpage

* Omisión de un regresor cuando hay multicolinealidad
   :PROPERTIES:
   :header-args: :tangle ./pub/scripts/OmisionRegresorMulticol.inp
   :END:

| Guión: | {{{lugar(OmisionRegresorMulticol.inp)}}}            |


#+begin_src hansl :exports none
nulldata 1000                          # tamano de muestra en la simulacion

matrix C = {1 , 0; -10, 1}

loop 10000 --progressive --quiet
     series S  = randgen(N,  10 , 5)   # primer regresor

     series X  = randgen(N, -10 , 5)  
     matrix Z  = {S,X}
     Z *= C'                           # note: use the transpose '
     series D = Z[,2]                  # segundo regresor

     series U  = randgen(N, 0   , 40 ) # perturbaciones

     series Y = 1 + 10*S -1*D + U      # regresando
     
     ols Y 0 S D                       # Regresion MCO modelo completo
     scalar C1     = $coeff(const)
     scalar S1     = $coeff(S)
     scalar D1     = $coeff(D)
     scalar sigma1 = $sigma

     ols Y 0 D                         # Regresion MCO omision S
     scalar C2     = $coeff(const)
     scalar D2     = $coeff(D)
     scalar sigma2 = $sigma

     ols Y 0 S                         # Regresion MCO omision D
     scalar C3     = $coeff(const)
     scalar S3     = $coeff(S)
     scalar sigma3 = $sigma

     print C1 S1 D1 sigma1
     print C2    D2 sigma2
     print C3 S3    sigma3
endloop
#+end_src  

# +LATEX: \clearpage
#+latex: \vspace{10pt}
#+latex: \noindent
*Código completo de la práctica*
#+latex: \vspace{10pt}
\lstinputlisting{scripts/OmisionRegresorMulticol.inp}
#+LATEX: \clearpage



* Omisión de un regresor cuando hay multicolinealidad
   :PROPERTIES:
   :header-args: :tangle ./pub/scripts/ErrorDeEspecificacionPorInclusion.inp
   :END:

| Guión: | {{{lugar(ErrorDeEspecificacionPorInclusion.inp)}}}                                   |


#+begin_src hansl :exports none
nulldata 1000                        # tamano de muestra en la simulacion

matrix C = { 1, 0, 0, 0; \
           100, 1, 0, 0; \
            -6, 0, 1, 0; \
             0, 1, 0, 1}

loop 10000 --progressive --quiet
     series S  = randgen(N,  0 , 1)  # primer regresor

     series U  = randgen(N,  0 , 1)  # perturbaciones

     series X  = randgen(N,  0 , 1) 

     matrix Z  = {S,X,U,U}
     Z *= C'                         # note: use the transpose '
     
     series D = Z[,2]                # segundo regresor fuertemente correlado solo con S (Variable Irrelevante)

     series E = Z[,4]                # segundo regresor fuertemente correlado solo con U

     series F = Z[,3]/10             # segundo regresor fuertemente correlado con S y U

     series Y = 1 - S + U            # regresando beta1=1 y beta2=-1
     
     ols Y 0 S                       # Regresion MCO modelo completo (estimadores insesgados)
     scalar C1     = $coeff(const)
     scalar S1     = $coeff(S)
     scalar sigma1 = $sigma

     ols Y 0 S D                     # Incusion regresor ortogonal a U (no a S) (Variable irrelevante)
     scalar C2     = $coeff(const)
     scalar S2     = $coeff(S)
     scalar D2     = $coeff(D)
     scalar sigma2 = $sigma

     ols Y 0 S E                     # Incusion regresor ortogonal a S (no a U)
     scalar C3     = $coeff(const)
     scalar S3     = $coeff(S)
     scalar E3     = $coeff(E)
     scalar sigma3 = $sigma

     ols Y 0 S F                     # Incusion regresor ni ortogonal a S ni a U
     scalar C4     = $coeff(const)
     scalar S4     = $coeff(S)
     scalar F4     = $coeff(F)
     scalar sigma4 = $sigma

     print C1 S1    sigma1
     print C2 S2 D2 sigma2
     print C3 S3 E3 sigma3
     print C4 S4 F4 sigma4
endloop
corr U S D E F
#+end_src  

# +LATEX: \clearpage
#+latex: \vspace{10pt}
#+latex: \noindent
*Código completo de la práctica*
#+latex: \vspace{10pt}
\lstinputlisting{scripts/ErrorDeEspecificacionPorInclusion.inp}
#+LATEX: \clearpage

